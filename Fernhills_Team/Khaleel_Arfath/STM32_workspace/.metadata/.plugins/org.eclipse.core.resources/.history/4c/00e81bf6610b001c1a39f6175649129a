/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************/
#include "stm32f4xx.h"
#include "main.h"

//#include "stm32f1xx.h"

void init_USART1(void);
char USART1_receive(void);
void USART1_transmit(char data);
void USART1_transmitString(char* data_string);
//
//char *temp;
//
//void Clock_Config(){						//HSI CLOCK 16MHz
//	RCC->CR		|=	RCC_CR_HSION;			// Enable HSI
//	while(!(RCC->CR & RCC_CR_HSIRDY));		// Wait till HSI READY
//}
//
// void USART_6(){
//	RCC->AHB1ENR 	|= 	RCC_AHB1ENR_GPIOCEN; 			// Enable clock for GPIOC
//	RCC->APB2ENR	|= 	RCC_APB2ENR_USART6EN;   		// Enable clock for USART6
//	GPIOC->AFR[0]	 =	0x88000000;  					// enable USART6_TX to PC6 and USART6_RX to PC7
//	GPIOC->MODER	|=	GPIO_MODER_MODER6_1;			// configuring the USART6 ALTERNATE function PC6
//	GPIOC->MODER	|=	GPIO_MODER_MODER7_1;				// configuring the USART6 ALTERNATE function PC7
//	USART6->BRR		 =	0x682;    						// 9600 Baud
//	USART6->CR1		|=	USART_CR1_UE |USART_CR1_TE|USART_CR1_RE|USART_CR1_RXNEIE; 	// USART6 enable(c=[TE: Transmitter enable %RE:Receiver enable]2=[RXNEIE:RXNE interrupt enable]2=[UE: USART enable] )
//}
//
// void SendChar(char Tx){
//    while(!(USART6->SR & USART_SR_TXE));  			// wait TXBUFF=1
//    USART6->DR=Tx;
// }
//
// void SendTxt(char *Adr)
// {
//   while(*Adr){
//     SendChar(*Adr);
//     Adr++;
//   }
// }
// char receive(){
// 	if((USART6->SR & USART_SR_RXNE)!=0){
// 		char data = USART6->DR;
//
// 		return data;
// 	}
// }
//
// int main(void){
// 	Clock_Config();
// 	USART_6();
// 	SendTxt("WELCOME:\n");
// 	while(1)
// 	{
// 		temp = receive();
// 		SendTxt(&temp);
// 	}
// }

// initialize the USART with default settings (1start, 8data, 1stop bit) and 115200 baud rate
void init_USART1(void) {
	//	enable GPIO port A clock , alternate function I/O clock and USART1 clock
	RCC->APB2ENR |= (RCC_APB2ENR_IOPAEN  | RCC_APB2ENR_AFIOEN | RCC_APB2ENR_USART1EN);
	// enable USART, transmitter and receiver
	USART1->CR1 |= (USART_CR1_UE | USART_CR1_TE | USART_CR1_RE);
	// 	set baud rate divider to achieve a baud rate of 115200 from the 72MHz PCLK2
	USART1->BRR = 625;	// alternatively e.g. BRR = 7500 for 9600 baud
	// 	set PA9 as alternate function push-pull output with max speed of 50MHz
	GPIOA->CRH &= ~GPIO_CRH_CNF9_0;
	GPIOA->CRH |= (GPIO_CRH_CNF9_1 | GPIO_CRH_MODE9_0 | GPIO_CRH_MODE9_1);
	// 	set PA10 as floating input
	GPIOA->CRH &= ~(GPIO_CRH_CNF10_1 | GPIO_CRH_MODE10_0 | GPIO_CRH_MODE10_1);
	GPIOA->CRH |= GPIO_CRH_CNF10_0;
}
// receive one character and return it
char USART1_receive(void) {
	// wait until the USART data register is not empty
	while (!((USART1->SR) & USART_SR_RXNE))
		;
	// return the content (first byte) of the data register
	return ((USART1->DR) & 0xFF);
}
// send one character
void USART1_transmit(char data) {
	// 	wait until the USART data register is empty i.e. ready to transmit
	while (!((USART1->SR) & USART_SR_TXE));
	//	write character to be sent into the data register
	USART1->DR = (data & 0xFF);
	// wait until transmission is completed
	while (!((USART1->SR) & USART_SR_TC));
}
// send a whole C-string
void USART1_transmitString(char* data_string){
	while( *data_string != 0 ){
		USART1_transmit(*data_string++);
	}
}

void main()
{
	init_USART1();
	 USART1_transmit('A');

	 while(1)
	 {}
}
/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
