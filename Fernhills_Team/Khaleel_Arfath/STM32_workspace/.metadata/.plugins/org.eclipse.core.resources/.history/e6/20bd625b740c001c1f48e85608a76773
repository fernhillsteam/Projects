/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************/
//#include "stm32f4xx.h" 					 // Device header
//#include "string.h"
//
//volatile char data;
//
//void USART_INIT(void);
//void USART2_WRITE( char* ch);
//char GetChar(void);
//void USART2_IRQHandler(void);
//
//int main(void)
//{
//USART_INIT();
//	while(1)
//	{
//		// USART_INIT();
////		 USART2_WRITE("USART2 WORKS");
//}
//
//}
//
//void USART_INIT(void)
//{
//RCC->APB1ENR  |=0x20000;   				// Enabling APB1 Clock
//RCC->AHB1ENR  |=0x1;      			        // Enabling AHB1 Clock
//GPIOA->AFR[0] |=0x0700;	                                // Setting PA2 as alternate function
//GPIOA->MODER  |=0x20;                                   // Setting PA2 as output
//USART2->BRR   =0x0683; 		                        // Setting the baude rate (9600 @ 16MHz)
//USART2->CR1   |=0x8;  		     	                // Enabling the transmitter
//USART2->CR1   |=0x2000;			                // Enabling the USART2
//
//USART2->CR1	|=	(5<<5);			//	Enable TXE and RXNE interrupts
//NVIC_EnableIRQ(USART2_IRQn);	//	Enable global interrupt vector
//}
//
//void USART2_WRITE( char* ch)
//{
//	for (uint8_t i=0; i < strlen(ch);i++)
//	{
//	while(!(USART2->SR & 0x0080)){}
//	USART2->DR = ch[i] & 0xFF;			//Sending the data
//	}
//}
//
//char GetChar(void){
//
//	while(!(USART2->SR & (1<<5)));	//	Wait untill recieve complete.
//	char temp= USART2->DR;
//	GPIOA->ODR &=~(1<<5);
//	return temp;
//
//}
//
//void USART2_IRQHandler(void){
//
//	 if(USART2->SR & (1<<5)){
//		//	Recieved data ready to read.
//		data= USART2->DR;
//		USART2->DR=data;
//	}
//}

#include "stm32f4xx.h"                  // Device header
#include <stdio.h>

void USART_Init(void)
{
	RCC->APB1ENR |= 0x20000; 							// 0000 0000 0000 0010 0000 0000 0000 0000   enable USART2 port
  RCC->AHB1ENR |= 1;      							// 0000 0000 0000 0000 0000 0000 0000 0001   enable port A

	GPIOA->AFR[0] |= 0x7700;
	GPIOA->MODER	|= 0x00A0;              // 0000 0000 0000 0000 0000 0000 1010 0000   enable alternate function for PA2 and PA3

	USART2->BRR |= 0x0683;								// 9600 baud rate
	USART2->CR1 |= 0x000C;								// 0000 0000 0000 0000 0000 0000 0000 1100   enable rx and tx
	USART2->CR1 |= 0x2000;  							// 0000 0000 0000 0010 0000 0000 0000 0000   enable USART
}

int USART_write(int ch)
{
	while(!(USART2->SR & 0x0080))    			// wait for tx buffer to be empty
	{
		USART2->DR = (ch & 0xFF);
		return ch;
	}
}

int USART_read(void)
{
	while(!(USART2->SR & 0x0020))					// wait for rx buffer to be empty
	{
		return USART2->DR;
	}
}

struct __FILE{int handle;};
FILE __stdin = {0};
FILE __stdout = {1};
FILE __stderr = {2};

int fgetc(FILE *f)
{
	int c;
	c = USART_read();
	if (c == '\r')
	{
			USART_write(c);
		c= '\n';
	}
	USART_write(c);
	return c;
}

int fputc(int c, FILE *f)
{
	return USART_write(c);
}

int main(void)
{
	int n;
	char str[100];

	printf("Hello from the other side\n");
	fprintf(stdout, "test for stdout\r\n");
	fprintf(stderr, "test for stderr\r\n");

	while(1)
	{
		printf("How old are you?");
		scanf("%d",&n);
		printf("Your age is : %d\r\n",n);
		printf("Enter your first name");
		gets(str);
		printf("I like your style: ");
		puts(str);
		printf("\r\n");
	}
}

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
