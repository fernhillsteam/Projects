/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************/
#include "stm32f4xx.h"
#include "main.h"
//
//char *temp;
//
//void Clock_Config(){						//HSI CLOCK 16MHz
//	RCC->CR		|=	RCC_CR_HSION;			// Enable HSI
//	while(!(RCC->CR & RCC_CR_HSIRDY));		// Wait till HSI READY
//}
//
// void USART_6(){
//	RCC->AHB1ENR 	|= 	RCC_AHB1ENR_GPIOCEN; 			// Enable clock for GPIOC
//	RCC->APB2ENR	|= 	RCC_APB2ENR_USART6EN;   		// Enable clock for USART6
//	GPIOC->AFR[0]	 =	0x88000000;  					// enable USART6_TX to PC6 and USART6_RX to PC7
//	GPIOC->MODER	|=	GPIO_MODER_MODER6_1;			// configuring the USART6 ALTERNATE function PC6
//	GPIOC->MODER	|=	GPIO_MODER_MODER7_1;				// configuring the USART6 ALTERNATE function PC7
//	USART6->BRR		 =	0x682;    						// 9600 Baud
//	USART6->CR1		|=	USART_CR1_UE |USART_CR1_TE|USART_CR1_RE|USART_CR1_RXNEIE; 	// USART6 enable(c=[TE: Transmitter enable %RE:Receiver enable]2=[RXNEIE:RXNE interrupt enable]2=[UE: USART enable] )
//}
//
// void SendChar(char Tx){
//    while(!(USART6->SR & USART_SR_TXE));  			// wait TXBUFF=1
//    USART6->DR=Tx;
// }
//
// void SendTxt(char *Adr)
// {
//   while(*Adr){
//     SendChar(*Adr);
//     Adr++;
//   }
// }
// char receive(){
// 	if((USART6->SR & USART_SR_RXNE)!=0){
// 		char data = USART6->DR;
//
// 		return data;
// 	}
// }
//
// int main(void){
// 	Clock_Config();
// 	USART_6();
// 	SendTxt("WELCOME:\n");
// 	while(1)
// 	{
// 		temp = receive();
// 		SendTxt(&temp);
// 	}
// }

void set_system_clock_to_72Mhz(void)
{
	// Necessary wait states for Flash for high speeds
	FLASH->ACR = 0x12;
	// Enable HSE
	RCC->CR |= (1 << 16);
	// Wait untill HSE settles down
	while (!(RCC->CR & (1 << 17)));
	// Set PREDIV2 division factor to 5
	RCC->CFGR |= (0b0100 << 4);
	// Set PLL2 multiplication factor to 8
	RCC->CFGR |= (0b0110 << 8);
	// Enable PLL2
	RCC->CR |= (1 << 26);
	// Wait untill PLL2 settles down
	while (!(RCC->CR & (1 << 27)));
	// Set PLL2 as PREDIV1 clock source
	RCC->CFGR |= (1 << 16);
	// Set PREDIV1 division factor to 5
	RCC->CFGR |= (0b0100 << 0);
	// Select Prediv1 as PLL source
	RCC->CFGR |= (1 << 16);
	// Set PLL1 multiplication factor to 9
	RCC->CFGR |= (0b0111 << 18);
	// Set APB1 to 36MHz
	RCC->CFGR |= 1 << 10;
	// Enable PLL
	RCC->CR |= (1 << 24);
	// Wait untill PLL settles down
	while (!(RCC->CR & (1 << 25)));
	// Finally, choose PLL as the system clock
	RCC->CFGR |= (0b10 << 0);
}

/*************************************************
* Main code starts from here
*************************************************/
void main(void)
{
	// Copy LMA to VMA for data section
	copy_data();

	// Set clock to 72 MHz
	set_system_clock_to_72Mhz();

	uint32_t i = 0;
	// Enable alternate function clock. Bit 0 in RCC APB2ENR register
	RCC->APB2ENR |= (1 << 0);
	// Enable GPIOA clock. Bit 2 in RCC APB2ENR register
	RCC->APB2ENR |= (1 << 2);
	// Enable clock for UART1 clock. Bit 14 in RCC APB2ENR register
	RCC->APB2ENR |= (1 << 14);

	// Make GPIOA Pin 9,10 (PA9, PA10) alternate-function output (0b1010)
	GPIOA->CRH &= 0xFFFFF00F;
	GPIOA->CRH |= 0x00000BB0;

	// Enable USART
	USART1->CR1 |= (1 << 13);
	// Word length - leave default (8 data)
	USART1->CR1 |= (0 << 12);
	// Number of stop bits - leave default (1 stop)
	USART1->CR2 |= (0b00 << 12);
	// Baud rate
	// BRR should be 468.75 for 9600 baud rate
	// Thus manista is 468 (0x1d4) and fraction is 12 (0xc) (12/16 is .75)
	// Making it 0x1d4c
	USART1->BRR = 0x1d4c;
	// Transmitter enable
	USART1->CR1 |= (1 << 3);
	// Receiver enable
	USART1->CR1 |= (1 << 2);

	while(1)
	{
		for (i=0; i<26; i++){
			USART1->DR = 'a' + i;
			while(!(USART1->SR & (1 << 6)));
		}
		for (i=0; i<26; i++){
			USART1->DR = 'A' + i;
			while(!(USART1->SR & (1 << 6)));
		}
		for (i=0; i<10; i++){
			USART1->DR = '0' + i;
			while(!(USART1->SR & (1 << 6)));
		}

		USART1->DR = '\n';
		while(!(USART1->SR & (1 << 6)));
		USART1->DR = '\r';
		while(!(USART1->SR & (1 << 6)));

		for(i=5000000; i>0; i--);
	}

	// Should never reach here
	return 0;
}
/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
