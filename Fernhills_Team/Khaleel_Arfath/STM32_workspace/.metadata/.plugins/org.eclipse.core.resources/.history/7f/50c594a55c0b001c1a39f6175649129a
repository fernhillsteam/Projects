/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************/
//#include "stm32f4xx.h"
//
//char *temp;
//
//void Clock_Config(){						//HSI CLOCK 16MHz
//	RCC->CR		|=	RCC_CR_HSION;			// Enable HSI
//	while(!(RCC->CR & RCC_CR_HSIRDY));		// Wait till HSI READY
//}
//
// void USART_6(){
//	RCC->AHB1ENR 	|= 	RCC_AHB1ENR_GPIOCEN; 			// Enable clock for GPIOC
//	RCC->APB2ENR	|= 	RCC_APB2ENR_USART6EN;   		// Enable clock for USART6
//	GPIOC->AFR[0]	 =	0x88000000;  					// enable USART6_TX to PC6 and USART6_RX to PC7
//	GPIOC->MODER	|=	GPIO_MODER_MODER6_1;			// configuring the USART6 ALTERNATE function PC6
//	GPIOC->MODER	|=	GPIO_MODER_MODER7_1;				// configuring the USART6 ALTERNATE function PC7
//	USART6->BRR		 =	0x682;    						// 9600 Baud
//	USART6->CR1		|=	USART_CR1_UE |USART_CR1_TE|USART_CR1_RE|USART_CR1_RXNEIE; 	// USART6 enable(c=[TE: Transmitter enable %RE:Receiver enable]2=[RXNEIE:RXNE interrupt enable]2=[UE: USART enable] )
//}
//
// void SendChar(char Tx){
//    while(!(USART6->SR & USART_SR_TXE));  			// wait TXBUFF=1
//    USART6->DR=Tx;
// }
//
// void SendTxt(char *Adr)
// {
//   while(*Adr){
//     SendChar(*Adr);
//     Adr++;
//   }
// }
// char receive(){
// 	if((USART6->SR & USART_SR_RXNE)!=0){
// 		char data = USART6->DR;
//
// 		return data;
// 	}
// }
//
// int main(void){
// 	Clock_Config();
// 	USART_6();
// 	SendTxt("WELCOME:\n");
// 	while(1)
// 	{
// 		temp = receive();
// 		SendTxt(temp);
// 	}
// }

//#include "stm32F4xx.h"
//
//void USART6_init(void);
//void USART6_write(int c);
//void delayMs(int);
//char USART6_read(void);
//
//int main (void) {
//    char c;
//    USART6_init();
//
//    while (1) {
//        c = USART6_read();
//        USART6_write(c);
//    }
//}
//
///* initialize USART6 to transmit at 9600 Baud */
//void USART6_init (void) {
//		RCC->AHB1ENR 	|= 	RCC_AHB1ENR_GPIOCEN; 			// Enable clock for GPIOC
//		RCC->APB2ENR	|= 	RCC_APB2ENR_USART6EN;   		// Enable clock for USART6
//
//    	RCC->AHB1ENR 	|= 	RCC_AHB1ENR_GPIOCEN; 			// Enable clock for GPIOC
//    	RCC->APB2ENR	|= 	RCC_APB2ENR_USART6EN;   		// Enable clock for USART6
//    	GPIOC->AFR[0]	 =	0x88000000;  					// enable USART6_TX to PC6 and USART6_RX to PC7
//    	GPIOC->MODER	|=	GPIO_MODER_MODER6_1;			// configuring the USART6 ALTERNATE function PC6
//    	GPIOC->MODER	|=	GPIO_MODER_MODER7_1;				// configuring the USART6 ALTERNATE function PC7
//
//    	USART6->BRR		 =	0x682;    						// 9600 Baud
//    	USART6->CR1		|=	USART_CR1_UE |USART_CR1_TE|USART_CR1_RE|USART_CR1_RXNEIE; 	// USART6 enable(c=[TE: Transmitter enable %RE:Receiver enable]2=[RXNEIE:RXNE interrupt enable]2=[UE: USART enable] )
//
//}
//
///* Write a character to USART6 */
//void USART6_write (int ch) {
//	    while(!(USART6->SR & USART_SR_TXE));  			// wait TXBUFF=1
//	    USART6->DR=ch;
//}
//
///* Read a character from USART6 */
//char USART6_read(void) {
//    while (!(USART6->SR &  USART_SR_RXNE)) {}   // wait until char arrives
//    return USART6->DR;
//}

#include "stm32F4xx.h"

void USART2_init(void);
void LED_blink(int value);
void delayMs(int);

/*----------------------------------------------------------------------------
  MAIN function
 *----------------------------------------------------------------------------*/
int main (void) {
    __disable_irq();                /* global disable IRQs */

    RCC->AHB1ENR |=  1;             /* enable GPIOA clock */
    GPIOA->MODER &= ~0x00000C00;    /* clear pin mode */
    GPIOA->MODER |=  0x00000400;    /* set pin to output mode */

    USART2_init();                  /* initialize USART2 */

    USART2->CR1 |= 0x0020;          /* enable Rx interrupt */
    NVIC_EnableIRQ(USART2_IRQn);    /* enable interrupt in NVIC */
    __enable_irq();                 /* global enable IRQs */

    while(1) {                      /* Loop forever */
    }
}

/*----------------------------------------------------------------------------
  Initialize UART pins, Baudrate
 *----------------------------------------------------------------------------*/
void USART2_init (void) {
    RCC->AHB1ENR |= 1;          /* Enable GPIOA clock */
    RCC->APB1ENR |= 0x20000;    /* Enable USART2 clock */

    /* Configure PA2 for USART2 TX */
    GPIOA->AFR[0] &= ~0xF000;
    GPIOA->AFR[0] |=  0x7000;   /* alt7 for USART2 */
    GPIOA->MODER  &= ~0x00C0;
    GPIOA->MODER  |=  0x0080;   /* enable alternate function for PA3 */

    USART2->BRR = 0x008B;       /* 115200 baud @ 16 MHz */
    USART2->CR1 = 0x0004;       /* enable Rx, 8-bit data */
    USART2->CR2 = 0x0000;       /* 1 stop bit */
    USART2->CR3 = 0x0000;       /* no flow control */
    USART2->CR1 |= 0x2000;      /* enable USART2 */
}

void USART2_IRQHandler(void) {
    char c;

    if (USART2->SR & 0x0020) {
        c = USART2->DR;             /* Read a character from USART2 */
        LED_blink(c);               /* blink the LED */
    }
}

/* turn on or off the LEDs according to the value */
void LED_blink(int value) {
    value %= 16;                    /* cap the max count at 15 */

    for (; value > 0; value--) {
        GPIOA->BSRR = 0x00000020;   /* turn on LED */
        delayMs(200);
        GPIOA->BSRR = 0x00200000;   /* turn off LED */
        delayMs(200);
    }
    delayMs(800);
}

void delayMs(int n) {
    int i;
    for (; n > 0; n--)
        for (i = 0; i < 2000; i++) ;
}
/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
