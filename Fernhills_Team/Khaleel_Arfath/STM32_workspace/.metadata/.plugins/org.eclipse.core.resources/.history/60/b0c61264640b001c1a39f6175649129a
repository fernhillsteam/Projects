/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************/
#include "stm32f4xx.h"
#include "main.h"
////
//char *temp;
//
//void Clock_Config(){						//HSI CLOCK 16MHz
//	RCC->CR		|=	RCC_CR_HSION;			// Enable HSI
//	while(!(RCC->CR & RCC_CR_HSIRDY));		// Wait till HSI READY
//}
//
// void USART_6(){
//	RCC->AHB1ENR 	|= 	RCC_AHB1ENR_GPIOCEN; 			// Enable clock for GPIOC
//	RCC->APB2ENR	|= 	RCC_APB2ENR_USART6EN;   		// Enable clock for USART6
//	GPIOC->AFR[0]	 =	0x88000000;  					// enable USART6_TX to PC6 and USART6_RX to PC7
//	GPIOC->MODER	|=	GPIO_MODER_MODER6_1;			// configuring the USART6 ALTERNATE function PC6
//	GPIOC->MODER	|=	GPIO_MODER_MODER7_1;				// configuring the USART6 ALTERNATE function PC7
//	USART6->BRR		 =	0x682;    						// 9600 Baud
//	USART6->CR1		|=	USART_CR1_UE |USART_CR1_TE|USART_CR1_RE|USART_CR1_RXNEIE; 	// USART6 enable(c=[TE: Transmitter enable %RE:Receiver enable]2=[RXNEIE:RXNE interrupt enable]2=[UE: USART enable] )
//}
//
// void SendChar(char Tx){
//    while(!(USART6->SR & USART_SR_TXE));  			// wait TXBUFF=1
//    USART6->DR=Tx;
// }
//
// void SendTxt(char *Adr)
// {
//   while(*Adr){
//     SendChar(*Adr);
//     Adr++;
//   }
// }
// char receive(){
// 	if((USART6->SR & USART_SR_RXNE)!=0){
// 		char data = USART6->DR;
//
// 		return data;
// 	}
// }
//
// int main(void){
// 	Clock_Config();
// 	USART_6();
// 	SendTxt("WELCOME:\n");
// 	while(1)
// 	{
// 		temp = receive();
// 		SendTxt(&temp);
// 	}
// }

#include "stm32f4xx.h"                  // Device header
#include "stdio.h"
#include "stdint.h"

volatile uint8_t msg[]="HELLO WORLD\n";
uint8_t adc=16;
volatile char data;
char MSG[12];
char Dma_value[1];
	//	Function prototype	//
void	GPIO_Init(void);
void	UartInit(void);
void SendChar(char c);
char GetChar(void);

void delay(uint32_t time){
	while(time--);
}

void USART2_IRQHandler(void){

	 if(USART2->SR & (1<<5)){
		//	Recieved data ready to read.
		data= USART2->DR;
		USART2->DR=data;
	}
}


//void DMA1_Stream5_IRQHandler(void){
//
//	if(DMA1->HISR & (1<<11)){
//
//		DMA1->HIFCR &=~(1<<11);
//
//		DMA1_Stream6->CR	|= (1<<0);		//	Stream6 Enable Tx
//	}
//}

//void DMA1_Stream6_IRQHandler(void){
//
//	if(DMA1->HISR & (1<<21)){
//
//		DMA1->HIFCR &=~(1<<21);
//
//		DMA1_Stream5->CR	|= (1<<0);		//	Stream5 Enable Rx
//	}
//}





int	main(){

	GPIO_Init();
	UartInit();
	DMA1_Stream5->CR	|= (1<<0);		//	Stream5 Enable Rx
 	while(1)
	{
//
//		SendChar(temp);
//		sprintf(MSG,"\ragirlik:%d\n",adc);
//		for(uint8_t i=0; i<sizeof(MSG);i++){
//		SendChar(MSG[i]);
//		delay(250000);
		}

	}

void	GPIO_Init()
{
	RCC->AHB1ENR	|=	(1<<0);		// GPIOA clock enable
	GPIOA->MODER	|=	(1<<5)|(1<<7);		// PA2 and PA3 Alternate function mode
	GPIOA->AFR[0]	|=	(7<<8)|(7<<12);		// PA9 and PA10 usart1 selected
	GPIOA->OSPEEDR	|=	(3<<4 )|(3<<6);	//	Selected high speed for uart

	GPIOA->MODER	|= (1<<10);	// PA5 set to output
}

void UartInit()
{
	RCC->APB1ENR	|=	(1<<17);		//	Usart2 clock enabled
	USART2->CR1	|=(1<<2)|(1<<3);	//	Reciever enabled,Transmitter enabled
	USART2->BRR	=	0x683;			//	uart baudrate config
	USART2->CR1	|=	(1<<13);		//	Usart2 enabled
	USART2->CR1	&=	~(1<<12) & ~(1<<10);	//	Word length and parity control settings
	USART2->CR2	&=	~(3<<12);		//	Select stop bit quantity
	USART2->CR1	|=	(5<<5);			//	Enable TXE and RXNE interrupts
	NVIC_EnableIRQ(USART2_IRQn);	//	Enable global interrupt vector

	//	DMA configurations	//
//	RCC->AHB1ENR |=	1<<21;			//	Dma1 clock enable
//
//  USART2->CR3	|= (3<<6);			//	Enable dma for reciever and transmitter
//
//	DMA1_Stream5->CR	|=(4<<25);	// Select dma stream5 channel4 for Rx
//	DMA1_Stream6->CR	|=(4<<25);	// Select dma stream6 channel4 for Tx
//
//	DMA1_Stream5->CR	|=(2<<13);	// Memory data size selected word
//	DMA1_Stream6->CR	|=(2<<13);	// Memory data size selected word

//	DMA1_Stream5->CR	|=(2<<11);	// Periperal data size selected word
//	DMA1_Stream6->CR	|=(2<<11);	// Periperal data size selected word
//
//	DMA1_Stream6->CR	|=(1<<10);	// Enabled memory incremented mode for transmit

//	DMA1_Stream6->CR	|=(1<<8);		// Circular mode enable
//	DMA1_Stream5->CR	|=(1<<8);		// Circular mode enable

//	DMA1_Stream6->CR	|=(1<<6);		// Data direction selected memory to peripheral
//	DMA1_Stream5->CR	&=~(3<<6);	// Data direction selected peripheral to memory
//
//	DMA1_Stream6->CR	|=(1<<4);		// Transfer complete interrupt enable
//	DMA1_Stream5->CR	|=(1<<4);		// Transfer complete interrupt enable
//
//	DMA1_Stream6->NDTR =1;
//	DMA1_Stream5->NDTR =1;
//
//	DMA1_Stream6->PAR	= (uint32_t)&USART2->DR;
//	DMA1_Stream5->PAR	= (uint32_t)&USART2->DR;
//
//	DMA1_Stream6->M0AR = (uint32_t)Dma_value;
//	DMA1_Stream5->M0AR = (uint32_t)Dma_value;
//
//	NVIC_EnableIRQ(DMA1_Stream5_IRQn);
//	NVIC_EnableIRQ(DMA1_Stream6_IRQn);
}

void SendChar(char c){

	USART2->DR |=	c;	//	Load the data in the DR.
	GPIOA->ODR |=(1<<5);
	while(!(USART2->SR & (1<<6)));	//	Wait untill transmit complete.

}

char GetChar(void){

	while(!(USART2->SR & (1<<5)));	//	Wait untill recieve complete.
	char temp= USART2->DR;
	GPIOA->ODR &=~(1<<5);
	return temp;

}


/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
