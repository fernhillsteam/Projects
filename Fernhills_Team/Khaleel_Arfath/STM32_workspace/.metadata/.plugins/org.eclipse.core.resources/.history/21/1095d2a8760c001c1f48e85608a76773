/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
  * All rights reserved.</center></h2>
  *
  * This software component is licensed by ST under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************/
//#include "stm32f4xx.h" 					 // Device header
//#include "string.h"
//
//volatile char data;
//
//void USART_INIT(void);
//void USART2_WRITE( char* ch);
//char GetChar(void);
//void USART2_IRQHandler(void);
//
//int main(void)
//{
//USART_INIT();
//	while(1)
//	{
//		// USART_INIT();
////		 USART2_WRITE("USART2 WORKS");
//}
//
//}
//
//void USART_INIT(void)
//{
//RCC->APB1ENR  |=0x20000;   				// Enabling APB1 Clock
//RCC->AHB1ENR  |=0x1;      			        // Enabling AHB1 Clock
//GPIOA->AFR[0] |=0x0700;	                                // Setting PA2 as alternate function
//GPIOA->MODER  |=0x20;                                   // Setting PA2 as output
//USART2->BRR   =0x0683; 		                        // Setting the baude rate (9600 @ 16MHz)
//USART2->CR1   |=0x8;  		     	                // Enabling the transmitter
//USART2->CR1   |=0x2000;			                // Enabling the USART2
//
//USART2->CR1	|=	(5<<5);			//	Enable TXE and RXNE interrupts
//NVIC_EnableIRQ(USART2_IRQn);	//	Enable global interrupt vector
//}
//
//void USART2_WRITE( char* ch)
//{
//	for (uint8_t i=0; i < strlen(ch);i++)
//	{
//	while(!(USART2->SR & 0x0080)){}
//	USART2->DR = ch[i] & 0xFF;			//Sending the data
//	}
//}
//
//char GetChar(void){
//
//	while(!(USART2->SR & (1<<5)));	//	Wait untill recieve complete.
//	char temp= USART2->DR;
//	GPIOA->ODR &=~(1<<5);
//	return temp;
//
//}
//
//void USART2_IRQHandler(void){
//
//	 if(USART2->SR & (1<<5)){
//		//	Recieved data ready to read.
//		data= USART2->DR;
//		USART2->DR=data;
//	}
//}

#include "stm32f4xx.h"                  // Device header
#include <stdio.h>

void USART1_Init(uint32_t BAUDRATE)
{

	/* GPIO port B Clock Enable  */
	RCC->AHB1ENR  |= 0x00000002;

	/*
	GPIOx_AFR[0] = GPIOx_AFRL
	GPIOx_AFR[1] = GPIOx_AFRH
	Alternate Function Mode 7 is avaliable for USART1.
	*/
	GPIOB->AFR[0] &= ~(15UL << (4 * 6));	// PB6 Alternate Function Mode = 0 (0000)
	GPIOB->AFR[0] &= ~(15UL << (4 * 7));	// PB7 Alternate Function Mode = 0 (0000)
	GPIOB->AFR[0] |=  ( 7UL << (4 * 6));	// PB6 Alternate Function Mode = 7 (0111)
	GPIOB->AFR[0] |=  ( 7UL << (4 * 7));	// PB7 Alternate Function Mode = 7 (0111)

	GPIOB->MODER  &= ~( 3UL << (2 * 6));	// Set PB6 as Reset State = 00 (0)
	GPIOB->MODER  &= ~( 3UL << (2 * 7));	// Set PB7 as Reset State = 00 (0)
	GPIOB->MODER  |=  ( 2UL << (2 * 6));	// Set PB6 as Alternate Function Mode = 10 (2)
	GPIOB->MODER  |=  ( 2UL << (2 * 7));	// Set PB7 as Alternate Function Mode = 10 (2)

	/* USART1 Clock Enable */
	RCC->APB2ENR	|=  ( 1UL <<  4);

	/* Set Baudrate */
	if(BAUDRATE == 2400) {
		USART1->BRR	= 0x88B8;				//   2400 Bps
	} else if(BAUDRATE == 9600)   {
		USART1->BRR = 0x222D;				//   9600 Bps
	} else if(BAUDRATE == 19200)  {
		USART1->BRR = 0x1118;				//  19200 Bps
	} else if(BAUDRATE == 38400)  {
		USART1->BRR = 0x88C;				//  38400 Bps
	} else if(BAUDRATE == 57600)  {
		USART1->BRR = 0x5B2;				//  57600 Bps
	} else if(BAUDRATE == 115200) {
		USART1->BRR = 0x2DA;				// 115200 Bps
	} else if(BAUDRATE == 230400) {
		USART1->BRR = 0x16C;				// 230400 Bps
	} else if(BAUDRATE == 460800) {
		USART1->BRR = 0xB6;					// 460800 Bps
	} else if(BAUDRATE == 921600) {
		USART1->BRR = 0x5C;					// 921600 Bps
	}

	/* Set Control Register Data */
	USART1->CR1 |= (1 <<  2);				// USART_CR1_RE - Receiver Enable
	USART1->CR1	|= (1 <<  3);				// USART_CR1_TE - Transmitter Enable
	USART1->CR1	|= (1 <<  5);				// USART_CR1_RXNEIE - RXNE Interrupt Enable
	USART1->CR1	|= (1 << 13);				// USART_CR1_UE - USART Enable

	NVIC->ISER[1]  |= 0x20;					// Enable USART1 Interrupt

	USART1->SR &= ~(0x40);					// Set Noise Detected Flag to 0
	}

void USART1_WriteChar(uint8_t character)
{
	while(!(USART1->SR & 0x80));			// USART_SR_TXE
  	USART1->DR = character;
}

void USART1_WriteString(uint8_t * string)
{
	while(*string)
	{
		USART1_WriteChar(*string);
		*string++;
	}
}

void USART1_IRQHandler(void)
{
	uint8_t Receive_Characher;

	/* RXNE handler */
	if (USART1->SR & 0x20)					// USART_SR_RXNE
	{
		Receive_Characher = (USART1->DR & 0xFF);
		USART1_WriteChar(Receive_Characher);
	}
}

void main()
{
	 USART1_Init(9600);
	 USART1_WriteString("UART DEMO TX RX");

	 while(1)
	 {}
}

/************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/
